JsonNode root = mapper.readTree(jsonString);
WeatherDTO dto = mapper.readValue(jsonString, WeatherDTO.class);

// manually fix mismatched ones
dto.setCity(root.get("city_name").asText());
dto.setCondition(root.get("weather_condition_condition").asText());


Feature	readTree()	readValue()
Return type	JsonNode (tree model)	Java object (POJO, DTO, Map, List)
Flexibility	Very flexible, schema-free	Requires known schema/class
Mapping	Manual field extraction (.get())	Automatic mapping if names match
Best for	Dynamic JSON, partial fields, unknown structure	Structured JSON, DTOs, full mapping

To accept Json as string then access the data we use JsonNode.


readTree when the object and not ready or schema we dont know. It give us JsonNode type which we can handle by above style
readValue maps the string json into our object


For response

‚öñÔ∏è When to use what
- Use Map ‚Üí for simple, flat JSON responses.
- Use ObjectNode / JsonNode ‚Üí when you need nested JSON structures or dynamic building.
- Use DTO classes ‚Üí when you want strong typing, validation, and consistent API contracts across your project.


example using map

Map<String, Object> response = new HashMap<>();
response.put("message", "Driver removed successfully"); // String
response.put("status", true);                           // Boolean
response.put("code", 200);                              // Integer
response.put("timestamp", System.currentTimeMillis());  // Long

üîé Why Object instead of String
- Flexibility:
JSON values can be strings, numbers, booleans, or even nested objects/arrays.
If you use Map<String, String>, you‚Äôre limited to only string values.
- Serialization:
Spring Boot (via Jackson) automatically converts a Map<String, Object> into JSON.
For example:

